function MismatchOptionStruct = base_options(varargin)
    import NeuromorphicControlToolbox.mismatch.*

    mismatch_functions = containers.Map( ...
        {'Tunable Sigmoid', 'First Order Lag', 'Neuron', 'Synapse with Facilitation', 'Synapse with Depression', 'Modulatory Synapse', 'Event Demux', 'Event Mux', 'Continuous to Event', 'Event to Continuous'},...
        { ...
            create_mismatch_func_tunable_sigmoid(), ...
            create_mismatch_func_first_order_lag(), ...
            create_mismatch_func_neuron(), ...
            create_mismatch_func_synapse_with_facilitation(), ...
            create_mismatch_func_synapse_with_depression(), ...
            create_mismatch_func_modulatory_synapse(), ...
            create_mismatch_func_event_demux(), ...
            create_mismatch_func_event_mux(), ...
            create_mismatch_func_continuous_to_event(), ...
            create_mismatch_func_event_to_continuous() ...
        }...
     );

    MismatchOptionStruct = set_options(varargin{:}, 'mismatchFunctions', mismatch_functions);
end

function mismatch_map = create_mismatch_func_tunable_sigmoid()
    mismatch_map = containers.Map(...
        {'gain', 'bias', 'slope'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gain'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'bias'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'slope'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_first_order_lag()
    mismatch_map = containers.Map(...
        {'gain', 'timescale'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gain'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'rel_timescale'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_neuron()
    mismatch_map = containers.Map(...
        {'gain', 'bias', 'slope', 'timescale'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gfm', 'gsp', 'gsm', 'gup', 'gum'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'dfm', 'dsp', 'dsm', 'dup', 'dum', 'Iapp_base', 'tresh'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'mfm', 'msp', 'msm', 'mup', 'mum'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'rel_membrane', 'rel_fast', 'rel_slow', 'rel_ultraslow'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_synapse_with_facilitation()
    mismatch_map = containers.Map(...
        {'gain', 'bias', 'slope', 'timescale'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gsyn', 'gsyn_in'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'dsyn', 'dsyn_in'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'msyn', 'msyn_in'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'rel_timescale'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_synapse_with_depression()
    mismatch_map = containers.Map(...
        {'gain', 'bias', 'slope', 'timescale'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gsyn', 'gsyn_in'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'dsyn', 'dsyn_in', 'dsyn_dep'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'msyn', 'msyn_in', 'msyn_dep'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'rel_facilitation', 'rel_depression'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_modulatory_synapse()
    mismatch_map = containers.Map(...
        {'gain', 'mod_gain', 'bias', 'slope', 'timescale'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gsyn_pos','gsyn_neg'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'base_val'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'dsyn_pos', 'dsyn_neg'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'msyn_pos', 'msyn_neg'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'rel_timescale'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_event_demux()
    mismatch_map = containers.Map(...
        {'gain', 'bias', 'slope'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gsyn_pos', 'gsyn_neg'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'dsyn_signal_pos', 'dsyn_signal_neg', 'dsyn_event_pos', 'dsyn_event_neg'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gain_signal_pos', 'gain_signal_neg', 'gain_event_pos', 'gain_event_neg'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_event_mux()
    mismatch_map = containers.Map(...
        {'gain', 'bias', 'slope'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gsyn_pos', 'gsyn_neg'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'dsyn_signal_pos', 'dsyn_signal_neg', 'dsyn_event_pos', 'dsyn_event_neg'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gain_signal_pos', 'gain_signal_neg', 'gain_event_pos', 'gain_event_neg'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_continuous_to_event()
    mismatch_map = containers.Map(...
        {'bias'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'tresh'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_event_to_continuous()
    mismatch_map = containers.Map(...
        {'gain'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gain'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end


function simins = mismatch_params_from_list(model_work,blPath,simins,list,rand_func)
    for p = list
        try
            value = model_work.evalin(get_param(blPath, p{1}));
        catch E
            error(['Param value "' p{1} '" from block "' blPath '" cannot be evaluated.']);
        end
        for j = 1:length(simins)
            new_value = rand_func(value);
            simins(j) = simins(j).setBlockParameter(blPath, p{1}, num2str(new_value, '%.5e'));
        end
    end
end

function value = monteLogCutNormal(center, log_stddev, log_span)
    if 0 > log_stddev
        error("monteLogCUtNormal expected log_stddev >= 0");
    end
    if 0 > log_span
        error("monteLogCUtNormal expected log_span >= 0");
    end
    value = center * 10^distrib(log_stddev,log_span/2);
end

function value = monteCutNormal(center, stddev, span)
    if 0 > stddev
        error("monteCUtNormal expected stddev >= 0");
    end
    if 0 > span
        error("monteCUtNormal expected span >= 0");
    end
    value = center + distrib(stddev,span/2);
end

function r = distrib(stddev, cutoff)
	r = stddev*randn(); % Normally distributed ~ N(0,std^2)
    if r < -cutoff || r > cutoff
        r = (rand() - 0.5)*2*cutoff; % Uniformly distributed ~ U(-cutoff, cutoff)
    end
end