function mismatchOption = base_options(varargin)
    % Generates a mismatchOption base configuration for blocks of the Simulink library.
    %
    % Description
    % -----------
    %   mismatchOption = base_options()
    %       Generates the base mismatchOption for the toolbox.
    %
    %   mismatchOption = base_options(mismatchOption)
    %       Add to a custom mismatchOption the base mismatchOption for the toolbox.
    %
    %   mismatchOption = base_options(name, value, ...)
    %       Create a mismatchOption using the syntax of :func:`set_options` then add to it
    %       the base mismatchOption for the toolbox.
    %
    %   mismatchOption = base_options(mismatchOption, name, value)
    %       Add to a custom mismatchOption then add name-value options using the syntax of :func:`set_options` 
    %       then add to it the base mismatchOption for the toolbox.
    %
    % Inputs
    % ------
    %   name: char or string
    %       Name of the option to set.
    %   value: misc
    %       Value of the option to set.
    %
    % Optional Input
    % --------------
    %   mismatchOption: struct
    %       Preexisting mismatchOption.
    %
    % Output
    % ------
    %   mismatchOption: struct
    %       Resulting structuring containing the preset options.
    %
    % :Name-Value Inputs:
    %   see :func:`set_options`

    import NeuroCont.mismatch.*

    mismatch_functions = containers.Map( ...
        {'Tunable Sigmoid', 'First Order Lag', 'Neuron', 'Synapse with Facilitation', 'Synapse with Depression', 'Modulatory Synapse', 'Event Demux', 'Event Mux', 'Continuous to Event', 'Event to Continuous'},...
        { ...
            create_mismatch_func_tunable_sigmoid(), ...
            create_mismatch_func_first_order_lag(), ...
            create_mismatch_func_neuron(), ...
            create_mismatch_func_synapse_with_facilitation(), ...
            create_mismatch_func_synapse_with_depression(), ...
            create_mismatch_func_modulatory_synapse(), ...
            create_mismatch_func_event_demux(), ...
            create_mismatch_func_event_mux(), ...
            create_mismatch_func_continuous_to_event(), ...
            create_mismatch_func_event_to_continuous() ...
        }...
     );

    mismatchOption = set_options(varargin{:}, 'mismatchFunctions', mismatch_functions);
end

function mismatch_map = create_mismatch_func_tunable_sigmoid()
    mismatch_map = containers.Map(...
        {'gain', 'bias', 'slope'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gain'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'bias'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'slope'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_first_order_lag()
    mismatch_map = containers.Map(...
        {'gain', 'timescale'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gain'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'rel_timescale'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_neuron()
    mismatch_map = containers.Map(...
        {'gain', 'bias', 'slope', 'timescale'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gfm', 'gsp', 'gsm', 'gup', 'gum'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'dfm', 'dsp', 'dsm', 'dup', 'dum', 'Iapp_base', 'tresh'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'mfm', 'msp', 'msm', 'mup', 'mum'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'rel_membrane', 'rel_fast', 'rel_slow', 'rel_ultraslow'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_synapse_with_facilitation()
    mismatch_map = containers.Map(...
        {'gain', 'bias', 'slope', 'timescale'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gsyn', 'gsyn_in'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'dsyn', 'dsyn_in'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'msyn', 'msyn_in'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'rel_timescale'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_synapse_with_depression()
    mismatch_map = containers.Map(...
        {'gain', 'bias', 'slope', 'timescale'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gsyn', 'gsyn_in'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'dsyn', 'dsyn_in', 'dsyn_dep'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'msyn', 'msyn_in', 'msyn_dep'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'rel_facilitation', 'rel_depression'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_modulatory_synapse()
    mismatch_map = containers.Map(...
        {'gain', 'mod_gain', 'bias', 'slope', 'timescale'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gsyn_pos','gsyn_neg'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'base_val'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'dsyn_pos', 'dsyn_neg'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'msyn_pos', 'msyn_neg'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'rel_timescale'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_event_demux()
    mismatch_map = containers.Map(...
        {'gain', 'bias', 'slope'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gsyn_pos', 'gsyn_neg'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'dsyn_signal_pos', 'dsyn_signal_neg', 'dsyn_event_pos', 'dsyn_event_neg'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gain_signal_pos', 'gain_signal_neg', 'gain_event_pos', 'gain_event_neg'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_event_mux()
    mismatch_map = containers.Map(...
        {'gain', 'bias', 'slope'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gsyn_pos', 'gsyn_neg'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'dsyn_signal_pos', 'dsyn_signal_neg', 'dsyn_event_pos', 'dsyn_event_neg'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width)),...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gain_signal_pos', 'gain_signal_neg', 'gain_event_pos', 'gain_event_neg'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_continuous_to_event()
    mismatch_map = containers.Map(...
        {'bias'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'tresh'}, @(value) monteCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end

function mismatch_map = create_mismatch_func_event_to_continuous()
    mismatch_map = containers.Map(...
        {'gain'},...
        { ...
            @(blPath, simins, model_work, mismatch_param) mismatch_params_from_list(model_work, blPath, simins, {'gain'}, @(value) monteLogCutNormal(value,mismatch_param.std,mismatch_param.width))...
        }...
    );
end


function simins = mismatch_params_from_list(model_work,blPath,simins,list,rand_func)
    for p = list
        try
            value = model_work.evalin(get_param(blPath, p{1}));
        catch E
            error(['Param value "' p{1} '" from block "' blPath '" cannot be evaluated.']);
        end
        for j = 1:length(simins)
            new_value = rand_func(value);
            simins(j) = simins(j).setBlockParameter(blPath, p{1}, num2str(new_value, '%.5e'));
        end
    end
end

function value = monteLogCutNormal(center, log_stddev, log_span)
    if 0 > log_stddev
        error("monteLogCUtNormal expected log_stddev >= 0");
    end
    if 0 > log_span
        error("monteLogCUtNormal expected log_span >= 0");
    end
    value = center * 10^distrib(log_stddev,log_span/2);
end

function value = monteCutNormal(center, stddev, span)
    if 0 > stddev
        error("monteCUtNormal expected stddev >= 0");
    end
    if 0 > span
        error("monteCUtNormal expected span >= 0");
    end
    value = center + distrib(stddev,span/2);
end

function r = distrib(stddev, cutoff)
	r = stddev*randn(); % Normally distributed ~ N(0,std^2)
    if r < -cutoff || r > cutoff
        r = (rand() - 0.5)*2*cutoff; % Uniformly distributed ~ U(-cutoff, cutoff)
    end
end